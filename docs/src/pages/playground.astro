---
import Layout from '../layouts/PlaygroundLayout.astro';
---

<Layout title="CSS Logical Properties Playground">
  <div id="playground-app">
    <!-- 插件配置区域 -->
    <div class="playground-config">
      <div class="config-header">
        <h3>Plugin Configuration</h3>
        <div class="config-actions">
          <button id="reset-btn" class="btn-secondary" type="button">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M4 12a8 8 0 0 1 8-8V2.5L16 6l-4 3.5V8a6 6 0 1 0 6 6h1.5a7.5 7.5 0 1 1-15.5 0z"/>
            </svg>
            Reset to Example
          </button>
        </div>
      </div>
      <div class="config-grid">
        <div class="config-group">
          <label for="output-order">Output Order:</label>
          <select id="output-order">
            <option value="ltr-first">LTR First</option>
            <option value="rtl-first">RTL First</option>
          </select>
        </div>
        
        <div class="config-group">
          <label for="ltr-selector">LTR Selector:</label>
          <input type="text" id="ltr-selector" value='[dir="ltr"]' placeholder='[dir="ltr"]' />
        </div>
        
        <div class="config-group">
          <label for="rtl-selector">RTL Selector:</label>
          <input type="text" id="rtl-selector" value='[dir="rtl"]' placeholder='[dir="rtl"]' />
        </div>
      </div>
    </div>

    <!-- 编辑器区域 -->
    <div class="playground-editors">
      <div class="editor-panel">
        <div class="editor-header">
          <h4>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
            </svg>
            Input CSS (Logical Properties)
          </h4>
          <div class="editor-actions">
            <button id="format-input" class="btn-icon" title="Format CSS">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M3 3h18v2H3V3zm0 4h12v2H3V7zm0 4h18v2H3v-2zm0 4h12v2H3v-2zm0 4h18v2H3v-2z"/>
              </svg>
            </button>
          </div>
        </div>
        <textarea id="input-editor" class="editor" spellcheck="false"></textarea>
      </div>

      <div class="editor-panel">
        <div class="editor-header">
          <h4>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M19,19H5V5H19V19Z"/>
            </svg>
            Output CSS (Physical Properties)
          </h4>
          <div class="editor-actions">
            <button id="copy-output" class="btn-icon" title="Copy to Clipboard">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/>
              </svg>
            </button>
          </div>
        </div>
        <textarea id="output-editor" class="editor readonly" readonly spellcheck="false"></textarea>
      </div>
    </div>

    <!-- 实时预览区域 -->
    <div class="playground-preview">
      <div class="preview-header">
        <h4>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z"/>
          </svg>
          Live Preview
        </h4>
        <div class="preview-controls">
          <label class="radio-label">
            <input type="radio" name="preview-direction" value="ltr" checked>
            <span>LTR</span>
          </label>
          <label class="radio-label">
            <input type="radio" name="preview-direction" value="rtl">
            <span>RTL</span>
          </label>
        </div>
      </div>
      <div id="preview-container" dir="ltr">
        <div class="preview-element">
          <h5>Preview Element</h5>
          <p>This element demonstrates how the CSS logical properties work. Try changing the direction to see the RTL/LTR behavior.</p>
          <div class="nested-element">
            <span>Nested Content</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 错误显示 -->
  <div id="error-display" class="error-display hidden">
    <div class="error-content">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"/>
      </svg>
      <span id="error-message"></span>
    </div>
  </div>
</Layout>

<script>
  // Default CSS example
  const DEFAULT_CSS = `.container {
  margin-inline: 1rem;
  padding-block: 2rem;
  border-inline-start: 2px solid blue;
  float: inline-start;
}

.scroll-area {
  scroll-margin-inline: 10px;
  scroll-padding-block: 5px;
}

.gradient-example {
  background: linear-gradient(to inline-end, red, blue);
  padding: 1rem;
  margin-block: 1rem;
}

.complex-layout {
  margin-inline-start: 2rem;
  padding-inline-end: 1rem;
  border-inline: 1px solid #ccc;
  text-align: start;
}`;

  let inputEditor, outputEditor;

  // 简化的逻辑属性转换函数
  function transformLogicalCSS(css, options = {}) {
    const { 
      ltrSelector = '[dir="ltr"]', 
      rtlSelector = '[dir="rtl"]',
      outputOrder = 'ltr-first'
    } = options;

    try {
      let result = css;
      let additionalRules = [];
      
      // 转换 margin-inline
      result = result.replace(/margin-inline:\s*([^;]+);/g, (match, value) => {
        return `margin-left: ${value};\n  margin-right: ${value};`;
      });
      
      // 转换 padding-block
      result = result.replace(/padding-block:\s*([^;]+);/g, (match, value) => {
        return `padding-top: ${value};\n  padding-bottom: ${value};`;
      });
      
      // 转换 margin-block
      result = result.replace(/margin-block:\s*([^;]+);/g, (match, value) => {
        return `margin-top: ${value};\n  margin-bottom: ${value};`;
      });
      
      // 转换 border-inline-start
      result = result.replace(/border-inline-start:\s*([^;]+);/g, (match, value) => {
        const ltrRule = `${ltrSelector} .container {\n  border-left: ${value};\n}`;
        const rtlRule = `${rtlSelector} .container {\n  border-right: ${value};\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        return ''; // 移除原始规则
      });
      
      // 转换 float: inline-start
      result = result.replace(/float:\s*inline-start;/g, () => {
        const ltrRule = `${ltrSelector} .container {\n  float: left;\n}`;
        const rtlRule = `${rtlSelector} .container {\n  float: right;\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        return ''; // 移除原始规则
      });
      
      // 转换 scroll-margin-inline
      result = result.replace(/scroll-margin-inline:\s*([^;]+);/g, (match, value) => {
        return `scroll-margin-left: ${value};\n  scroll-margin-right: ${value};`;
      });
      
      // 转换 scroll-padding-block
      result = result.replace(/scroll-padding-block:\s*([^;]+);/g, (match, value) => {
        return `scroll-padding-top: ${value};\n  scroll-padding-bottom: ${value};`;
      });
      
      // 转换 linear-gradient to inline-end
      result = result.replace(/linear-gradient\(to inline-end,([^)]+)\)/g, (match, colors) => {
        const ltrGradient = `linear-gradient(to right,${colors})`;
        const rtlGradient = `linear-gradient(to left,${colors})`;
        
        // 添加方向特定的规则
        const ltrRule = `${ltrSelector} .gradient-example {\n  background: ${ltrGradient};\n}`;
        const rtlRule = `${rtlSelector} .gradient-example {\n  background: ${rtlGradient};\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        
        return ltrGradient; // 默认使用LTR版本
      });
      
      // 转换 margin-inline-start
      result = result.replace(/margin-inline-start:\s*([^;]+);/g, (match, value) => {
        const ltrRule = `${ltrSelector} .complex-layout {\n  margin-left: ${value};\n}`;
        const rtlRule = `${rtlSelector} .complex-layout {\n  margin-right: ${value};\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        return ''; // 移除原始规则
      });
      
      // 转换 padding-inline-end
      result = result.replace(/padding-inline-end:\s*([^;]+);/g, (match, value) => {
        const ltrRule = `${ltrSelector} .complex-layout {\n  padding-right: ${value};\n}`;
        const rtlRule = `${rtlSelector} .complex-layout {\n  padding-left: ${value};\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        return ''; // 移除原始规则
      });
      
      // 转换 border-inline
      result = result.replace(/border-inline:\s*([^;]+);/g, (match, value) => {
        return `border-left: ${value};\n  border-right: ${value};`;
      });
      
      // 转换 text-align: start
      result = result.replace(/text-align:\s*start;/g, () => {
        const ltrRule = `${ltrSelector} .complex-layout {\n  text-align: left;\n}`;
        const rtlRule = `${rtlSelector} .complex-layout {\n  text-align: right;\n}`;
        additionalRules.push(outputOrder === 'ltr-first' ? [ltrRule, rtlRule] : [rtlRule, ltrRule]);
        return ''; // 移除原始规则
      });
      
      // 添加额外的规则
      if (additionalRules.length > 0) {
        result += '\n\n/* Direction-specific rules */\n';
        additionalRules.forEach(rules => {
          result += rules.join('\n\n') + '\n\n';
        });
      }
      
      return result;
    } catch (error) {
      throw new Error(`Transformation failed: ${error.message}`);
    }
  }

  // Show error message
  function showError(message) {
    const errorDisplay = document.getElementById('error-display');
    const errorMessage = document.getElementById('error-message');
    if (errorDisplay && errorMessage) {
      errorMessage.textContent = message;
      errorDisplay.classList.remove('hidden');
      setTimeout(() => {
        errorDisplay.classList.add('hidden');
      }, 5000);
    }
  }

  // Transform CSS using our simplified transformation function
  function transformCSS() {
    try {
      const inputCSS = inputEditor.value;
      const outputOrder = document.getElementById('output-order').value;
      const ltrSelector = document.getElementById('ltr-selector').value || '[dir="ltr"]';
      const rtlSelector = document.getElementById('rtl-selector').value || '[dir="rtl"]';

      // Transform CSS using our simplified transformation function
      const result = transformLogicalCSS(inputCSS, {
        ltrSelector,
        rtlSelector,
        outputOrder
      });

      outputEditor.value = result;
      updatePreview(result);
    } catch (error) {
      console.error('CSS transformation error:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      outputEditor.value = `/* Error transforming CSS: ${errorMessage} */`;
      showError(`CSS transformation failed: ${errorMessage}`);
    }
  }

  // Update live preview
  function updatePreview(css) {
    let styleElement = document.getElementById('preview-styles');
    
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.id = 'preview-styles';
      document.head.appendChild(styleElement);
    }
    
    styleElement.textContent = css;
  }

  // Copy output CSS
  function copyOutput() {
    if (!outputEditor) return;
    
    const outputCSS = outputEditor.value;
    navigator.clipboard.writeText(outputCSS).then(() => {
      const btn = document.getElementById('copy-output');
      if (btn) {
        const originalHTML = btn.innerHTML;
        btn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"/>
          </svg>
        `;
        btn.setAttribute('title', 'Copied!');
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.setAttribute('title', 'Copy to Clipboard');
        }, 2000);
      }
    }).catch(() => {
      showError('Failed to copy to clipboard');
    });
  }

  // Reset to default example
  function resetToExample() {
    if (inputEditor) {
      inputEditor.value = DEFAULT_CSS;
      transformCSS();
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    // Get editor elements
    inputEditor = document.getElementById('input-editor');
    outputEditor = document.getElementById('output-editor');
    
    // Set initial value
    inputEditor.value = DEFAULT_CSS;
    
    // Configuration change listeners
    document.getElementById('output-order')?.addEventListener('change', transformCSS);
    document.getElementById('ltr-selector')?.addEventListener('input', () => {
      setTimeout(transformCSS, 300);
    });
    document.getElementById('rtl-selector')?.addEventListener('input', () => {
      setTimeout(transformCSS, 300);
    });

    // Input change listener with debounce
    let inputTimeout;
    inputEditor?.addEventListener('input', () => {
      clearTimeout(inputTimeout);
      inputTimeout = setTimeout(transformCSS, 300);
    });

    // Button listeners
    document.getElementById('copy-output')?.addEventListener('click', copyOutput);
    document.getElementById('reset-btn')?.addEventListener('click', resetToExample);

    // Preview direction toggle
    document.querySelectorAll('input[name="preview-direction"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        const direction = e.target.value;
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.setAttribute('dir', direction);
        }
      });
    });

    // Close error on click
    document.getElementById('error-display')?.addEventListener('click', () => {
      document.getElementById('error-display')?.classList.add('hidden');
    });
  }

  // Initialize everything when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    setupEventListeners();
    transformCSS(); // Initial transformation
  });
</script>
          <div class="editor-actions">
            <button id="format-input" class="btn-icon" title="Format CSS">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M3 3h18v2H3V3zm0 4h12v2H3V7zm0 4h18v2H3v-2zm0 4h12v2H3v-2zm0 4h18v2H3v-2z"/>
              </svg>
            </button>
          </div>
        </div>
        <div id="input-editor" class="editor-container"></div>
      </div>

      <div class="editor-panel">
        <div class="editor-header">
          <h4>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M19,19H5V5H19V19Z"/>
            </svg>
            Output CSS (Physical Properties)
          </h4>
          <div class="editor-actions">
            <button id="copy-output" class="btn-icon" title="Copy to Clipboard">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/>
              </svg>
            </button>
          </div>
        </div>
        <div id="output-editor" class="editor-container readonly"></div>
      </div>
    </div>

    <!-- 实时预览区域 -->
    <div class="playground-preview">
      <div class="preview-header">
        <h4>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z"/>
          </svg>
          Live Preview
        </h4>
        <div class="preview-controls">
          <label class="radio-label">
            <input type="radio" name="preview-direction" value="ltr" checked>
            <span>LTR</span>
          </label>
          <label class="radio-label">
            <input type="radio" name="preview-direction" value="rtl">
            <span>RTL</span>
          </label>
        </div>
      </div>
      <div id="preview-container" dir="ltr">
        <div class="preview-element">
          <h5>Preview Element</h5>
          <p>This element demonstrates how the CSS logical properties work. Try changing the direction to see the RTL/LTR behavior.</p>
          <div class="nested-element">
            <span>Nested Content</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 错误显示 -->
  <div id="error-display" class="error-display hidden">
    <div class="error-content">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z"/>
      </svg>
      <span id="error-message"></span>
    </div>
  </div>
</Layout>

<script type="module">
  import postcss from 'postcss';
  import postcssLogicalPolyfill from '../../../src/index';

  // Default CSS example
  const DEFAULT_CSS = `.container {
  margin-inline: 1rem;
  padding-block: 2rem;
  border-inline-start: 2px solid blue;
  float: inline-start;
}

.scroll-area {
  scroll-margin-inline: 10px;
  scroll-padding-block: 5px;
}

.gradient-example {
  background: linear-gradient(to inline-end, red, blue);
  padding: 1rem;
  margin-block: 1rem;
}

.complex-layout {
  margin-inline-start: 2rem;
  padding-inline-end: 1rem;
  border-inline: 1px solid #ccc;
  text-align: start;
}`;

  let inputEditor, outputEditor;

  // Show error message
  function showError(message) {
    const errorDisplay = document.getElementById('error-display');
    const errorMessage = document.getElementById('error-message');
    if (errorDisplay && errorMessage) {
      errorMessage.textContent = message;
      errorDisplay.classList.remove('hidden');
      setTimeout(() => {
        errorDisplay.classList.add('hidden');
      }, 5000);
    }
  }

  // Initialize simple textarea editors with syntax highlighting via Prism
  async function initializeEditors() {
    try {
      // Create textarea elements for editors
      const inputContainer = document.getElementById('input-editor');
      const outputContainer = document.getElementById('output-editor');

      inputEditor = document.createElement('textarea');
      inputEditor.value = DEFAULT_CSS;
      inputEditor.style.cssText = `
        width: 100%;
        height: 100%;
        min-height: 350px;
        border: none;
        outline: none;
        resize: none;
        font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 16px;
        background: var(--monaco-bg);
        color: var(--playground-text);
        tab-size: 2;
      `;

      outputEditor = document.createElement('textarea');
      outputEditor.readOnly = true;
      outputEditor.style.cssText = `
        width: 100%;
        height: 100%;
        min-height: 350px;
        border: none;
        outline: none;
        resize: none;
        font-family: 'JetBrains Mono', 'Fira Code', 'Source Code Pro', monospace;
        font-size: 14px;
        line-height: 1.5;
        padding: 16px;
        background: var(--monaco-bg);
        color: var(--playground-text);
        tab-size: 2;
      `;

      inputContainer.appendChild(inputEditor);
      outputContainer.appendChild(outputEditor);

      // Add input listener with debounce
      let timeoutId;
      inputEditor.addEventListener('input', () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(transformCSS, 300);
      });

      // Handle tab key for indentation
      inputEditor.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = inputEditor.selectionStart;
          const end = inputEditor.selectionEnd;
          inputEditor.value = inputEditor.value.substring(0, start) + '  ' + inputEditor.value.substring(end);
          inputEditor.selectionStart = inputEditor.selectionEnd = start + 2;
        }
      });

      // Initial transformation
      transformCSS();
    } catch (error) {
      console.error('Failed to initialize editors:', error);
      showError('Failed to initialize editors. Please refresh the page.');
    }
  }

  // Transform CSS using the plugin
  async function transformCSS() {
    try {
      const inputCSS = inputEditor.value;
      const outputOrder = document.getElementById('output-order').value;
      const ltrSelector = document.getElementById('ltr-selector').value || '[dir="ltr"]';
      const rtlSelector = document.getElementById('rtl-selector').value || '[dir="rtl"]';

      // Process CSS with our plugin
      const result = await postcss([
        postcssLogicalPolyfill({
          ltr: { selector: ltrSelector },
          rtl: { selector: rtlSelector },
          outputOrder
        })
      ]).process(inputCSS, { from: undefined });

      outputEditor.value = result.css;
      updatePreview(result.css);
    } catch (error) {
      console.error('CSS transformation error:', error);
      const errorMessage = error.message || 'Unknown error';
      outputEditor.value = `/* Error: ${errorMessage} */`;
      showError(`CSS transformation failed: ${errorMessage}`);
    }
  }

  // Update live preview
  function updatePreview(css) {
    let styleElement = document.getElementById('preview-styles');
    
    if (!styleElement) {
      styleElement = document.createElement('style');
      styleElement.id = 'preview-styles';
      document.head.appendChild(styleElement);
    }
    
    styleElement.textContent = css;
  }

  // Toggle theme
  function handleThemeChange() {
    const newTheme = document.documentElement.dataset.theme || 'dark';
    if (inputEditor && outputEditor) {
      const bgColor = newTheme === 'dark' ? '#1e1e1e' : '#ffffff';
      const textColor = newTheme === 'dark' ? '#ffffff' : '#1f2937';
      
      inputEditor.style.background = bgColor;
      inputEditor.style.color = textColor;
      outputEditor.style.background = bgColor;
      outputEditor.style.color = textColor;
    }
  }

  // Copy output CSS
  function copyOutput() {
    if (!outputEditor) return;
    
    const outputCSS = outputEditor.value;
    navigator.clipboard.writeText(outputCSS).then(() => {
      const btn = document.getElementById('copy-output');
      if (btn) {
        const originalHTML = btn.innerHTML;
        btn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"/>
          </svg>
        `;
        btn.setAttribute('title', 'Copied!');
        setTimeout(() => {
          btn.innerHTML = originalHTML;
          btn.setAttribute('title', 'Copy to Clipboard');
        }, 2000);
      }
    }).catch(() => {
      showError('Failed to copy to clipboard');
    });
  }

  // Reset to default example
  function resetToExample() {
    if (inputEditor) {
      inputEditor.value = DEFAULT_CSS;
      transformCSS();
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    document.getElementById('output-order')?.addEventListener('change', transformCSS);
    document.getElementById('ltr-selector')?.addEventListener('input', () => {
      clearTimeout(window.transformTimeout);
      window.transformTimeout = setTimeout(transformCSS, 500);
    });
    document.getElementById('rtl-selector')?.addEventListener('input', () => {
      clearTimeout(window.transformTimeout);
      window.transformTimeout = setTimeout(transformCSS, 500);
    });

    document.getElementById('copy-output')?.addEventListener('click', copyOutput);
    document.getElementById('reset-btn')?.addEventListener('click', resetToExample);

    document.querySelectorAll('input[name="preview-direction"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        const direction = e.target.value;
        const previewContainer = document.getElementById('preview-container');
        if (previewContainer) {
          previewContainer.setAttribute('dir', direction);
        }
      });
    });

    // Listen for theme changes
    const observer = new MutationObserver(handleThemeChange);
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme']
    });

    document.getElementById('error-display')?.addEventListener('click', () => {
      document.getElementById('error-display')?.classList.add('hidden');
    });
  }

  // Initialize everything
  document.addEventListener('DOMContentLoaded', async () => {
    setupEventListeners();
    await initializeEditors();
  });
</script>
